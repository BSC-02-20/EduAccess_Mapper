# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SchoolDistributionAnalyzer
                                 A QGIS plugin
 This plugin aims at analysing how school are distributed across
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by group 1
        email                : bsc-02-20@unima.ac.mw
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import processing
import geopandas as gpd
import numpy as np
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
from qgis.utils import iface
from qgis.core import (QgsProject, QgsVectorLayer, QgsDistanceArea, 
                       QgsCoordinateReferenceSystem, QgsGeometry, QgsPointXY)

class SchoolDistributionAnalyzer:
    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.first_start = True
        self.dlg = None
        self.action = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.action = QAction("Analyze School Distribution", self.iface.mainWindow())
        self.action.triggered.connect(self.run)
        self.iface.addToolBarIcon(self.action)

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        self.iface.removeToolBarIcon(self.action)
        self.action = None

    def run(self):
        """Run method that performs all the real work."""
        # Fetch currently loaded layers
        layers = QgsProject.instance().layerTreeRoot().children()
        
        # Check if required layers are present
        school_layer = self.find_layer_by_keyword(layers, 'schools')
        district_layer = self.find_layer_by_keyword(layers, 'district')
        road_layer = self.find_layer_by_keyword(layers, 'road')

        if not (school_layer and district_layer and road_layer):
            QMessageBox.warning(
                self.iface.mainWindow(), 
                "Missing Layers", 
                "Please ensure you have school, district, and road layers loaded."
            )
            return

        # Perform analysis
        try:
            analysis_results = self.analyze_school_distribution(
                school_layer, district_layer, road_layer
            )
            self.display_analysis_results(analysis_results)
        except Exception as e:
            QMessageBox.critical(
                self.iface.mainWindow(), 
                "Analysis Error", 
                f"An error occurred during analysis: {str(e)}"
            )

    def find_layer_by_keyword(self, layers, keyword):
        """Find a layer containing a specific keyword."""
        for layer in layers:
            if keyword.lower() in layer.name().lower():
                return layer.layer()
        return None

    def analyze_school_distribution(self, school_layer, district_layer, road_layer):
        """
        Perform comprehensive school distribution analysis with robust column handling.
        
        Key Improvements:
        1. Dynamic column name detection
        2. Case-insensitive column matching
        3. Detailed error handling and debugging
        """
        # Convert layers to GeoPandas for analysis
        schools_gdf = self.layer_to_geopandas(school_layer)
        districts_gdf = self.layer_to_geopandas(district_layer)
        roads_gdf = self.layer_to_geopandas(road_layer)

        # Debugging: Print column names to understand layer structure
        print("Schools DataFrame Columns:", schools_gdf.columns)
        print("Districts DataFrame Columns:", districts_gdf.columns)

        # Strategy 1: Flexible District Column Detection
        def find_column(dataframe, target_keywords):
            """
            Find a column that matches given keywords, ignoring case.
            
            :param dataframe: GeoPandas DataFrame
            :param target_keywords: List of potential column names
            :return: Matched column name or None
            """
            lower_columns = [col.lower() for col in dataframe.columns]
            for keyword in target_keywords:
                if keyword.lower() in lower_columns:
                    # Return the actual column name with original casing
                    return dataframe.columns[lower_columns.index(keyword.lower())]
            return None

        # Possible district column keywords
        district_keywords = [
            'district', 
            'District', 
            'district_name', 
            'District_Name', 
            'DISTRICT'
        ]

        # Find district column dynamically
        district_column = find_column(districts_gdf, district_keywords)
        school_district_column = find_column(schools_gdf, district_keywords)

        # Raise informative error if no district column found
        if not district_column:
            raise ValueError(
                "Could not find a district column. "
                "Searched for keywords: " + ", ".join(district_keywords)
            )

        # Detect the CRS of each layer
        schools_crs = schools_gdf.crs
        districts_crs = districts_gdf.crs
        roads_crs = roads_gdf.crs

        # Use districts CRS as the common reference
        common_crs = districts_crs

        # Reproject layers to the common CRS if needed
        if schools_crs != common_crs:
            schools_gdf = schools_gdf.to_crs(common_crs)

        if roads_crs != common_crs:
            roads_gdf = roads_gdf.to_crs(common_crs)

        # Spatial Join with Flexible Column Handling
        try:
            # Perform spatial join using the dynamically found column
            schools_with_districts = gpd.sjoin(
                schools_gdf, 
                districts_gdf[[district_column, 'geometry']], 
                how='left'
            )

            # Count schools per district
            schools_per_district = schools_with_districts.groupby(district_column).size()

        except Exception as join_error:
            # Fallback Strategy: Manual Spatial Containment
            print(f"Spatial join failed. Attempting manual district assignment. Error: {join_error}")
            
            def find_district_manually(school_geom):
                """Find district by geometric containment."""
                containing_districts = districts_gdf[districts_gdf.contains(school_geom)]
                return (containing_districts[district_column].iloc[0] 
                        if len(containing_districts) > 0 
                        else 'Unassigned')

            schools_gdf['Assigned_District'] = schools_gdf.geometry.apply(find_district_manually)
            schools_per_district = schools_gdf.groupby('Assigned_District').size()

        # School Density Calculation
        districts_gdf['Area_sq_km'] = districts_gdf.geometry.area / 10**6
        districts_gdf['School_Density'] = schools_per_district / districts_gdf['Area_sq_km']

        # Additional Analysis (Distance to Roads)
        def calculate_road_distance(school_geom):
            """Calculate minimum distance to any road."""
            return min(
                school_geom.distance(road_geom) 
                for road_geom in roads_gdf.geometry
            )

        schools_gdf['Distance_to_Road'] = schools_gdf.geometry.apply(calculate_road_distance)

        # Spatial Distribution Metrics
        total_schools = len(schools_gdf)
        spatial_mean = schools_gdf.geometry.centroid.unary_union.centroid

        return {
            'total_schools': total_schools,
            'schools_per_district': schools_per_district.to_dict(),
            'school_density': districts_gdf['School_Density'].to_dict(),
            'avg_distance_to_road': schools_gdf['Distance_to_Road'].mean(),
            'spatial_mean_location': (spatial_mean.x, spatial_mean.y)
        }

    def layer_to_geopandas(self, qgis_layer):
        """Convert a QGIS vector layer to GeoPandas DataFrame."""
        # Implement appropriate conversion method
        # This is a placeholder and might need adjustment based on your specific data
        return gpd.read_file(qgis_layer.source())

    def display_analysis_results(self, results):
        """Display analysis results in a user-friendly manner."""
        result_text = (
            f"Total Schools: {results['total_schools']}\n\n"
            "Schools per District:\n"
        )
        for district, count in results['schools_per_district'].items():
            result_text += f"{district}: {count} schools\n"

        result_text += "\nSchool Density (schools/sq km):\n"
        for district, density in results['school_density'].items():
            result_text += f"{district}: {density:.2f}\n"

        result_text += (
            f"\nAverage Distance to Road: {results['avg_distance_to_road']:.2f} units\n"
            f"Spatial Mean Location: {results['spatial_mean_location']}"
        )

        QMessageBox.information(
            self.iface.mainWindow(), 
            "School Distribution Analysis", 
            result_text
        )

def classFactory(iface):
    """Load SchoolDistributionAnalyzer plugin."""
    return SchoolDistributionAnalyzer(iface)